# frozen_string_literal: false
#
#               tk.rb - Tk interface module using tcltklib
#                       by Yukihiro Matsumoto <matz@netlab.jp>

# use Shigehiro's tcltklib
require 'tcltklib'
require_relative 'tcltkip'             # TclTkIp Ruby extensions
require_relative 'tkcomm'
require_relative 'tk/tk_kernel'        # TkKernel base class
require_relative 'tk/tk_callback_entry' # TkCallbackEntry marker class
require_relative 'tk/util'             # TkUtil module (pure Ruby)
require_relative 'tkcore'              # TkCore module

# autoload
require 'tk/autoload'

# for Mutex
require 'thread'

# TclTkLib encoding methods - all UTF-8 now
module TclTkLib
  class << self
    def force_default_encoding=(mode); end
    def force_default_encoding? = true
    def default_encoding=(name); end
    def encoding=(name); end
    def encoding_name = 'utf-8'
    def encoding_obj = ::Encoding::UTF_8
    alias encoding encoding_name
    alias default_encoding encoding_name
  end
end

module Tk
  include TkCore
  extend Tk

  TCL_VERSION = INTERP._invoke_without_enc("info", "tclversion").freeze
  TCL_PATCHLEVEL = INTERP._invoke_without_enc("info", "patchlevel").freeze

  major, minor = TCL_VERSION.split('.')
  TCL_MAJOR_VERSION = major.to_i
  TCL_MINOR_VERSION = minor.to_i

  TK_VERSION  = INTERP._invoke_without_enc("set", "tk_version").freeze
  TK_PATCHLEVEL  = INTERP._invoke_without_enc("set", "tk_patchLevel").freeze

  major, minor = TK_VERSION.split('.')
  TK_MAJOR_VERSION = major.to_i
  TK_MINOR_VERSION = minor.to_i

  # Auto-load version-specific generated options if available
  # Generated by: rake tk:generate_options
  begin
    version_const = TCL_VERSION.gsub('.', '_')
    require_relative "tk/generated/options_#{version_const}"
  rescue LoadError
    warn "[ruby-tk] Generated options not found for Tcl #{TCL_VERSION}. Run: rake tk:generate_options[#{TCL_VERSION}]"
  end

  def Tk.const_missing(sym)
    case(sym)
    when :TCL_LIBRARY
      INTERP._invoke_without_enc('global', 'tcl_library')
      INTERP._invoke("set", "tcl_library").freeze

    when :TK_LIBRARY
      INTERP._invoke_without_enc('global', 'tk_library')
      INTERP._invoke("set", "tk_library").freeze

    when :LIBRARY
      INTERP._invoke("info", "library").freeze

    #when :PKG_PATH, :PACKAGE_PATH, :TCL_PACKAGE_PATH
    #  INTERP._invoke_without_enc('global', 'tcl_pkgPath')
    #  tk_split_simplelist(INTERP._invoke('set', 'tcl_pkgPath'))

    #when :LIB_PATH, :LIBRARY_PATH, :TCL_LIBRARY_PATH
    #  INTERP._invoke_without_enc('global', 'tcl_libPath')
    #  tk_split_simplelist(INTERP._invoke('set', 'tcl_libPath'))

    when :PLATFORM, :TCL_PLATFORM
      INTERP._invoke_without_enc('global', 'tcl_platform')
      Hash[*tk_split_simplelist(INTERP._invoke_without_enc('array', 'get',
                                                           'tcl_platform'))]

    when :ENV
      INTERP._invoke_without_enc('global', 'env')
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'env'))]

    #when :AUTO_PATH   #<===
    #  tk_split_simplelist(INTERP._invoke('set', 'auto_path'))

    #when :AUTO_OLDPATH
    #  tk_split_simplelist(INTERP._invoke('set', 'auto_oldpath'))

    when :AUTO_INDEX
      INTERP._invoke_without_enc('global', 'auto_index')
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'auto_index'))]

    when :PRIV, :PRIVATE, :TK_PRIV
      priv = {}
      if INTERP._invoke_without_enc('info', 'vars', 'tk::Priv') != ""
        var_nam = 'tk::Priv'
      else
        var_nam = 'tkPriv'
      end
      INTERP._invoke_without_enc('global', var_nam)
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get',
                                               var_nam))].each{|k,v|
        k.freeze
        case v
        when /^-?\d+$/
          priv[k] = v.to_i
        when /^-?\d+\.?\d*(e[-+]?\d+)?$/
          priv[k] = v.to_f
        else
          priv[k] = v.freeze
        end
      }
      priv

    else
      raise NameError, 'uninitialized constant Tk::' + sym.id2name
    end
  end

  def Tk.errorInfo
    INTERP._invoke_without_enc('global', 'errorInfo')
    INTERP._invoke_without_enc('set', 'errorInfo')
  end

  def Tk.errorCode
    INTERP._invoke_without_enc('global', 'errorCode')
    code = tk_split_simplelist(INTERP._invoke_without_enc('set', 'errorCode'))
    case code[0]
    when 'CHILDKILLED', 'CHILDSTATUS', 'CHILDSUSP'
      begin
        pid = Integer(code[1])
        code[1] = pid
      rescue
      end
    end
    code
  end

  def Tk.has_mainwindow?
    INTERP.has_mainwindow?
  end

  def root
    Tk::Root.new
  end

  def Tk.load_tclscript(file, enc=nil)
    if enc
      # TCL_VERSION >= 8.5
      tk_call('source', '-encoding', enc, file)
    else
      tk_call('source', file)
    end
  end

  def Tk.load_tcllibrary(file, pkg_name=None, interp=None)
    tk_call('load', file, pkg_name, interp)
  end

  def Tk.unload_tcllibrary(*args)
    if args[-1].kind_of?(Hash)
      keys = _symbolkey2str(args.pop)
      nocomp = (keys['nocomplain'])? '-nocomplain': None
      keeplib = (keys['keeplibrary'])? '-keeplibrary': None
      tk_call('unload', nocomp, keeplib, '--', *args)
    else
      tk_call('unload', *args)
    end
  end

  def Tk.pkgconfig_list(mod)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      elsif mod.const_defined?(:PACKAGE_NAME)
        pkgname = mod::PACKAGE_NAME
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_split_list(tk_call(pkgname + '::pkgconfig', 'list'))
  end

  def Tk.pkgconfig_get(mod, key)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_call(pkgname + '::pkgconfig', 'get', key)
  end

  def Tk.tcl_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tcl')
  end

  def Tk.tcl_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tcl', key)
  end

  def Tk.tk_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tk')
  end

  def Tk.tk_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tk', key)
  end

  def Tk.bell(nice = false)
    if nice
      tk_call_without_enc('bell', '-nice')
    else
      tk_call_without_enc('bell')
    end
    nil
  end

  def Tk.bell_on_display(win, nice = false)
    if nice
      tk_call_without_enc('bell', '-displayof', win, '-nice')
    else
      tk_call_without_enc('bell', '-displayof', win)
    end
    nil
  end

  def Tk.destroy(*wins)
    #tk_call_without_enc('destroy', *wins)
    tk_call_without_enc('destroy', *(wins.collect{|win|
                                       if win.kind_of?(TkWindow)
                                         win.epath
                                       else
                                         win
                                       end
                                     }))
  end

  def Tk.exit
    TkCore::INTERP.has_mainwindow? && tk_call_without_enc('destroy', '.')
  end

  ################################################

  def Tk.sleep(ms = nil, id = nil)
    if id
      var = (id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)
    else
      var = TkVariable.new
    end

    var.value = tk_call_without_enc('after', ms, proc{ var.value = 0 }) if ms
    var.thread_wait
    ms
  end

  def Tk.wakeup(id)
    ((id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)).value = 0
    nil
  end

  ################################################

  def Tk.pack(*args)
    TkPack.configure(*args)
  end
  def Tk.pack_forget(*args)
    TkPack.forget(*args)
  end
  def Tk.unpack(*args)
    TkPack.forget(*args)
  end

  def Tk.grid(*args)
    TkGrid.configure(*args)
  end
  def Tk.grid_forget(*args)
    TkGrid.forget(*args)
  end
  def Tk.ungrid(*args)
    TkGrid.forget(*args)
  end

  def Tk.place(*args)
    TkPlace.configure(*args)
  end
  def Tk.place_forget(*args)
    TkPlace.forget(*args)
  end
  def Tk.unplace(*args)
    TkPlace.forget(*args)
  end

  def Tk.update(idle=nil)
    if idle
      tk_call_without_enc('update', 'idletasks')
    else
      tk_call_without_enc('update')
    end
  end
  def Tk.update_idletasks
    update(true)
  end
  def update(idle=nil)
    # only for backward compatibility (This never be recommended to use)
    Tk.update(idle)
    self
  end

  # NOTE::
  #   If no eventloop-thread is running, "thread_update" method is same
  #   to "update" method. Else, "thread_update" method waits to complete
  #   idletask operation on the eventloop-thread.
  def Tk.thread_update(idle=nil)
    if idle
      tk_call_without_enc('thread_update', 'idletasks')
    else
      tk_call_without_enc('thread_update')
    end
  end
  def Tk.thread_update_idletasks
    thread_update(true)
  end

  def Tk.lower_window(win, below=None)
    tk_call('lower', _epath(win), _epath(below))
    nil
  end
  def Tk.raise_window(win, above=None)
    tk_call('raise', _epath(win), _epath(above))
    nil
  end

  def Tk.current_grabs(win = nil)
    if win
      window(tk_call_without_enc('grab', 'current', win))
    else
      tk_split_list(tk_call_without_enc('grab', 'current'))
    end
  end

  def Tk.focus(display=nil)
    if display == nil
      window(tk_call_without_enc('focus'))
    else
      window(tk_call_without_enc('focus', '-displayof', display))
    end
  end

  def Tk.focus_to(win, force=false)
    if force
      tk_call_without_enc('focus', '-force', win)
    else
      tk_call_without_enc('focus', win)
    end
  end

  def Tk.focus_lastfor(win)
    window(tk_call_without_enc('focus', '-lastfor', win))
  end

  def Tk.focus_next(win)
    TkManageFocus.next(win)
  end

  def Tk.focus_prev(win)
    TkManageFocus.prev(win)
  end

  def Tk.strictMotif(mode=None)
    bool(tk_call_without_enc('set', 'tk_strictMotif', mode))
  end

  def Tk.toUTF8(str, encoding = nil)
    _toUTF8(str, encoding)
  end

  def Tk.fromUTF8(str, encoding = nil)
    _fromUTF8(str, encoding)
  end
end

# Tk::Encoding module loaded after TkCore is defined
require_relative 'tk/encoding'
require_relative 'tk/bind_core'

module TkConfigMethod
  include TkUtil

  def __cget_cmd
    [self.path, 'cget']
  end
  private :__cget_cmd

  def __config_cmd
    [self.path, 'configure']
  end
  private :__config_cmd

  def __confinfo_cmd
    __config_cmd
  end
  private :__confinfo_cmd

  # Look up a declared option and convert value using its from_tcl converter.
  # Returns [converted_value, true] if option is declared, [original_value, false] otherwise.
  def __convert_from_tcl(slot, value)
    return [value, false] unless self.class.respond_to?(:resolve_option)
    opt = self.class.resolve_option(slot)
    return [value, false] unless opt
    [opt.from_tcl(value, widget: self), true]
  end
  private :__convert_from_tcl

  # Look up a declared option and convert value using its to_tcl converter.
  # Returns [converted_value, true] if option is declared, [original_value, false] otherwise.
  def __convert_to_tcl(slot, value)
    return [value, false] unless self.class.respond_to?(:resolve_option)
    opt = self.class.resolve_option(slot)
    return [value, false] unless opt
    [opt.to_tcl(value, widget: self), true]
  end
  private :__convert_to_tcl



  ################################

  def [](id)
    cget(id)
  end

  def []=(id, val)
    configure(id, val)
    val
  end

  def cget_tkstring(option)
    opt = option.to_s
    fail ArgumentError, "Invalid option `#{option.inspect}'" if opt.length == 0
    tk_call_without_enc(*(__cget_cmd << "-#{opt}"))
  end

  def __cget_core(slot)
    slot = slot.to_s
    fail ArgumentError, "Invalid option `#{slot.inspect}'" if slot.empty?

    # Resolve via Option registry (handles aliases too)
    opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(slot)
    slot = opt.tcl_name if opt

    # Get raw value from Tcl
    raw_value = tk_call_without_enc(*(__cget_cmd << "-#{slot}"))

    # Use Option registry for type conversion, otherwise return raw string
    if opt
      opt.from_tcl(raw_value, widget: self)
    else
      warn "#{self.class}#cget(:#{slot}) - option not declared, returning raw string"
      raw_value
    end
  end
  private :__cget_core

  def cget(slot)
    __cget_core(slot)
  end
  alias cget_strict cget

  # Check if an option requires a newer Tcl/Tk version.
  # If it does, emit a warning and return true (should skip this option).
  # Returns false if option is available or not version-restricted.
  def __skip_version_restricted_option?(option_name)
    return false unless self.class.respond_to?(:option_version_required)
    required_version = self.class.option_version_required(option_name)
    return false unless required_version

    warn "#{self.class}: option '#{option_name}' requires Tcl/Tk #{required_version}.0+ " \
         "(current: #{Tk::TK_VERSION}). Option ignored."
    true
  end
  private :__skip_version_restricted_option?

  def __configure_core(slot, value=None)
    if slot.kind_of? Hash
      slot = _symbolkey2str(slot)

      # Filter out version-restricted options before processing
      slot.delete_if { |k, _| __skip_version_restricted_option?(k) }

      # Resolve aliases via OptionDSL
      if self.class.respond_to?(:declared_optkey_aliases)
        self.class.declared_optkey_aliases.each do |alias_name, real_name|
          alias_name = alias_name.to_s
          if slot.has_key?(alias_name)
            slot[real_name.to_s] = slot.delete(alias_name)
          end
        end
      end

      tk_call(*(__config_cmd.concat(hash_kv(slot)))) if slot.size > 0

    else
      orig_slot = slot
      slot = slot.to_s
      if slot.length == 0
        fail ArgumentError, "Invalid option `#{orig_slot.inspect}'"
      end

      # Resolve alias via OptionDSL
      if self.class.respond_to?(:declared_optkey_aliases)
        _, real_name = self.class.declared_optkey_aliases.find { |k, _| k.to_s == slot }
        slot = real_name.to_s if real_name
      end

      # Check version restriction before attempting to configure
      return self if __skip_version_restricted_option?(slot)

      tk_call(*(__config_cmd << "-#{slot}" << value))
    end
    self
  end
  private :__configure_core

  def configure(slot, value=None)
    __configure_core(slot, value)
    self
  end

  def configure_cmd(slot, value)
    configure(slot, install_cmd(value))
  end

  # Get Tcl configure info for option(s)
  # Returns [option, dbname, dbclass, default, current] for single option
  # Returns array of above for all options (when slot is nil)
  # Alias entries return just [option, target]
  def configinfo(slot = nil)
    if slot
      slot = slot.to_s
      conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{slot}")), false, true)
      conf[TkComm::CONF_KEY] = conf[TkComm::CONF_KEY][1..-1]  # strip leading dash
      # Alias entries: strip dash from target (position 1 holds alias target)
      conf[TkComm::CONF_DBNAME] = conf[TkComm::CONF_DBNAME][1..-1] if conf.size == 2 && conf[TkComm::CONF_DBNAME]&.start_with?('-')
      conf
    else
      tk_split_simplelist(tk_call_without_enc(*__confinfo_cmd), false, false).map do |conflist|
        conf = tk_split_simplelist(conflist, false, true)
        conf[TkComm::CONF_KEY] = conf[TkComm::CONF_KEY][1..-1]  # strip leading dash
        conf[TkComm::CONF_DBNAME] = conf[TkComm::CONF_DBNAME][1..-1] if conf.size == 2 && conf[TkComm::CONF_DBNAME]&.start_with?('-')
        conf
      end
    end
  end

  # Get current values for option(s)
  # Returns {option => value} hash
  # Uses cget() which handles type conversion via Option registry
  def current_configinfo(slot = nil)
    if slot
      {slot.to_s => cget(slot)}
    else
      result = {}
      configinfo.each do |conf|
        # Skip alias entries (2 elements), only include real options
        result[conf[TkComm::CONF_KEY]] = cget(conf[TkComm::CONF_KEY]) if conf.size > 2
      end
      result
    end
  end
end

require_relative 'tkobject'
require_relative 'tkwindow'

TkWidget = TkWindow

# freeze core modules
#TclTkLib.freeze
#TclTkIp.freeze
#TkUtil.freeze
#TkKernel.freeze
#TkComm.freeze
#TkComm::Event.freeze
#TkCore.freeze
#Tk.freeze

module Tk
  RELEASE_DATE = '2014-10-19'.freeze

  autoload :AUTO_PATH,        'tk/variable'
  autoload :TCL_PACKAGE_PATH, 'tk/variable'
  autoload :PACKAGE_PATH,     'tk/variable'
  autoload :TCL_LIBRARY_PATH, 'tk/variable'
  autoload :LIBRARY_PATH,     'tk/variable'
  autoload :TCL_PRECISION,    'tk/variable'
end

# call setup script for Tk extension libraries (base configuration)
begin
  require 'tkextlib/version.rb'
  require 'tkextlib/setup.rb'
rescue LoadError
  # ignore
end
